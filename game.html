<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>Neon Slayer: Ultimate Update</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050505;
            color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none;
        }

        /* --- UI HUD --- */
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
            transition: opacity 0.5s; opacity: 0;
        }
        .hud-box {
            background: rgba(0, 0, 0, 0.6); border-left: 4px solid #fff;
            padding: 8px 15px; border-radius: 0 10px 10px 0;
            backdrop-filter: blur(5px); display: flex; flex-direction: column; min-width: 160px;
        }
        .label { font-size: 10px; text-transform: uppercase; color: #888; }
        .value { font-size: 20px; font-weight: bold; }
        .box-lvl { border-color: #00ffcc; color: #00ffcc; }
        .box-score { border-color: #ffd700; color: #ffd700; }
        .box-hi { border-color: #ff00ff; color: #ff00ff; }

        /* --- MAIN MENU --- */
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200; pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.1) 100%);
        }
        .menu-info { position: absolute; bottom: 40px; left: 40px; text-align: left; }
        .menu-title {
            font-size: 50px; font-weight: 900; color: #fff; letter-spacing: 5px;
            text-shadow: 0 0 20px #00ccff; font-style: italic; margin: 0; transform: skewX(-10deg);
        }
        .menu-ver { font-size: 14px; color: #ffaa00; letter-spacing: 2px; margin-bottom: 5px; }
        .menu-desc { font-size: 12px; color: #aaa; max-width: 300px; line-height: 1.5; }
        .start-btn-container { position: absolute; bottom: 40px; right: 40px; }
        .cyber-square-btn {
            width: 120px; height: 120px; background: rgba(0, 0, 0, 0.5); 
            border: 2px solid #00ffcc; color: #00ffcc;
            font-size: 20px; font-weight: 900; letter-spacing: 2px;
            cursor: pointer; position: relative; overflow: hidden; transition: 0.3s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2); backdrop-filter: blur(5px);
        }
        .cyber-square-btn::before { content: "START"; }
        .cyber-square-btn:hover { background: #00ffcc; color: #000; box-shadow: 0 0 40px #00ffcc; transform: scale(1.05) rotate(3deg); }

        /* --- TUTORIAL OVERLAY --- */
        #tutorial-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 190; backdrop-filter: blur(8px);
            flex-direction: column; align-items: center; justify-content: center;
        }
        .tut-keys { display: flex; gap: 40px; margin-bottom: 40px; }
        .key-group { text-align: center; }
        .key-visual { 
            display: inline-block; padding: 10px 20px; border: 2px solid #fff; 
            border-radius: 8px; font-weight: bold; font-size: 24px; color: #fff; margin: 5px;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        .key-desc { color: #00ffcc; font-size: 14px; margin-top: 10px; text-transform: uppercase; letter-spacing: 2px; }
        .skip-btn {
            padding: 15px 50px; background: transparent; border: 2px solid #ff0055; color: #ff0055;
            font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.3s;
        }
        .skip-btn:hover { background: #ff0055; color: white; box-shadow: 0 0 20px #ff0055; }

        /* --- NOTIFIKASI --- */
        #unlock-notify {
            position: absolute; top: 120px; left: -350px;
            width: 250px; background: rgba(0,0,0,0.85);
            border-left: 5px solid #00ffcc; padding: 20px;
            z-index: 150; transition: left 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px); box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
        }
        #unlock-notify.show { left: 20px; }
        #unlock-title { font-size: 20px; font-weight: bold; color: #00ffcc; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px; }
        #unlock-desc { font-size: 13px; color: #eee; line-height: 1.4; }

        #player-tutorial {
            position: absolute; pointer-events: none; opacity: 0;
            background: rgba(0,0,0,0.8); border: 1px solid #00ffcc; border-top: 3px solid #00ffcc;
            padding: 10px 15px; border-radius: 8px; text-align: center;
            transform: translate(-50%, 0); z-index: 90;
            transition: opacity 0.5s; backdrop-filter: blur(4px);
            min-width: 150px;
        }
        #player-tutorial b { display: block; color: #00ffcc; font-size: 14px; margin-bottom: 2px; }
        #player-tutorial span { color: #fff; font-size: 11px; }

        /* --- COMBO UI --- */
        #combo-container { position: absolute; top: 20px; right: 40px; text-align: right; pointer-events: none; transition: opacity 0.3s; opacity: 0; }
        #combo-value { font-size: 70px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #00ccff; margin: 0; }
        #combo-label { font-size: 14px; letter-spacing: 5px; color: #00ccff; text-transform: uppercase; margin-top: -10px; }

        /* --- UPGRADE CARDS --- */
        #level-up-modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);
        }
        .card-wrapper {
            display: flex; gap: 20px; position: relative; top: -100vh;
            transition: top 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .slide-in .card-wrapper { top: 0; }
        .card {
            width: 180px; height: 260px; background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444; border-top: 4px solid #fff;
            padding: 15px; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden;
            display: flex; flex-direction: column; justify-content: center;
        }
        .card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 20px rgba(255,255,255,0.2); background: #222; }
        .card h3 { font-size: 16px; margin-bottom: 10px; text-transform: uppercase; font-weight: 900; }
        .card p { color: #aaa; font-size: 12px; line-height: 1.4; }
        .card.upg-special { border-top-color: #ff00ff; } .card.upg-special h3 { color: #ff00ff; }
        .card.upg-dmg { border-top-color: #ffd700; color: #ffd700; }
        .card.upg-hp { border-top-color: #00ff88; color: #00ff88; }

        #boss-warning { display: none; position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); color: red; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red; z-index: 50; animation: blink 0.5s infinite; }
        @keyframes blink { 0% {opacity:1} 50% {opacity:0} 100% {opacity:1} }
        
        #game-over, #win-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
        button.retry-btn { padding: 15px 40px; font-size: 20px; background: white; border: none; cursor: pointer; font-weight: bold; margin-top: 20px; }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="main-menu">
        <div class="menu-info">
            <div class="menu-ver">V.8.0 ULTIMATE SWARM</div>
            <div class="menu-title">NEON SLAYER</div>
            <div class="menu-desc">
                Survive the endless swarm.<br>
                Enemies evolve as you level up.
            </div>
        </div>
        <div class="start-btn-container">
            <button class="cyber-square-btn" onclick="startTutorial()"></button>
        </div>
    </div>

    <div id="tutorial-overlay">
        <h2 style="color:white; letter-spacing:5px; margin-bottom:40px;">COMBAT SYSTEM</h2>
        <div class="tut-keys">
            <div class="key-group">
                <div><span class="key-visual">W</span><span class="key-visual">A</span><span class="key-visual">S</span><span class="key-visual">D</span></div>
                <div class="key-desc">MOVEMENT</div>
            </div>
            <div class="key-group">
                <div><span class="key-visual">MOUSE L-CLICK</span></div>
                <div class="key-desc">SLASH ATTACK</div>
            </div>
        </div>
        <button class="skip-btn" onclick="endTutorial()">SKIP TUTORIAL >></button>
    </div>

    <div id="unlock-notify">
        <div id="unlock-title">SKILL UNLOCKED</div>
        <div id="unlock-desc">Deskripsi skill disini.</div>
    </div>

    <div id="player-tutorial">
        <b id="pt-title">TRY IT!</b>
        <span id="pt-desc">Press RMB to Blink</span>
    </div>

    <div id="ui-layer">
        <div class="hud-box box-lvl"><span class="label">Target Level: 30</span><span class="value">LVL <span id="lvl-txt">1</span></span></div>
        <div class="hud-box box-score"><span class="label">Score</span><span class="value" id="score-txt">0</span></div>
        <div class="hud-box box-hi"><span class="label">High Score</span><span class="value" id="hi-score-txt">0</span></div>
    </div>

    <div id="combo-container"><p id="combo-value">0</p><p id="combo-label">Combo</p></div>
    <div id="boss-warning">⚠️ BOSS DETECTED ⚠️</div>

    <div id="level-up-modal">
        <h2 style="color:white; letter-spacing:3px; margin-bottom:10px;">SYSTEM UPGRADE</h2>
        <p style="color:#00ffcc; font-size: 14px; margin-bottom: 30px;">(Passive: All Stats Increased by 12%)</p>
        <div class="card-wrapper" id="cards-box"></div>
    </div>
    
    <div id="game-over"><h1 style="color: red;">SYSTEM FAILURE</h1><button class="retry-btn" onclick="location.reload()">REBOOT</button></div>
    <div id="win-screen"><h1 style="color: #00ff88;">MISSION COMPLETE</h1><button class="retry-btn" onclick="location.reload()">NEW GAME</button></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;

        const WORLD_SIZE = 3000;
        let gameState = "MENU"; 
        let frame = 0, score = 0, combo = 0, comboTimer = 0, shake = 0;
        let hiScore = localStorage.getItem("neonHiScore") || 0;
        let camera = { x: 0, y: 0 };
        let mouse = { x: 0, y: 0 };

        document.getElementById('hi-score-txt').innerText = hiScore;

        const player = {
            x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 25, speed: 5, baseSpeed: 5,
            hp: 100, maxHp: 100, 
            xp: 0, maxXp: 80, 
            level: 1, maxLevel: 30,
            angle: 0, dmgMult: 1, cdMult: 1,
            // Skills
            unlockedBlink: false,
            unlockedWave: false,
            unlockedRicochet: false,
            unlockedUlt: false,
            cdE: 0, maxCdE: 300, 
            cdRMB: 0, maxCdRMB: 180,
            cdQ: 0, maxCdQ: 660,
            ricochetCd: 0,
            isSwinging: false, swingTimer: 0, maxSwingTime: 10, swingDir: 1,
            magnetRange: 200, slashRange: 115,
            // Stats Tracking
            menuTargetX: WORLD_SIZE/2, menuTargetY: WORLD_SIZE/2,
            orbitals: [], droneLevel: 0, droneCd: 0, droneMaxCd: 60, staticFieldLevel: 0
        };

        let enemies = [], projectiles = [], enemyProjectiles = [], particles = [], orbs = [], damages = [], blinkTrails = [], boss = null;
        const keys = {};

        // --- UPGRADE SYSTEM ---
        const upgrades = [
            { id: 1, name: "SHARP EDGE", type: "upg-dmg", desc: "Attack power +20%", apply: () => player.dmgMult += 0.2 },
            { id: 2, name: "NEURAL LINK", type: "upg-cd", desc: "Cooldown speed +15%", apply: () => player.cdMult *= 0.85 },
            { id: 3, name: "NANO ARMOR", type: "upg-hp", desc: "Max HP +30 & Heal", apply: () => { player.maxHp += 30; player.hp += 30; } },
            { id: 4, name: "OVERCLOCK", type: "upg-spd", desc: "Move speed +10%", apply: () => player.speed += player.baseSpeed * 0.1 },
            { id: 5, name: "PLASMA ORBIT", type: "upg-special", desc: "Bola energi pelindung.", apply: () => { 
                player.orbitals.push({ angle: (Math.PI*2/3)*player.orbitals.length, speed: 0.05, radius: 80, size: 10 }); 
            }},
            { id: 6, name: "AUTO-DRONE", type: "upg-special", desc: "Drone penembak otomatis.", apply: () => { 
                player.droneLevel++; player.droneMaxCd = Math.max(20, 60 - (player.droneLevel * 5)); 
            }},
            { id: 7, name: "STATIC FIELD", type: "upg-special", desc: "Listrik area otomatis (Maks Lv 3).", apply: () => { if(player.staticFieldLevel < 3) player.staticFieldLevel++; }}
        ];

        function startTutorial() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function endTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.opacity = '1';
            keys['KeyW'] = false; keys['KeyS'] = false; keys['KeyA'] = false; keys['KeyD'] = false;
            gameState = "PLAYING";
        }

        function showUnlockNotification(title, desc, tutorialTitle, tutorialDesc) {
            const notifDuration = 4000; const gap = 1000;
            const notif = document.getElementById('unlock-notify');
            document.getElementById('unlock-title').innerText = title;
            document.getElementById('unlock-desc').innerText = desc;
            notif.classList.add('show');
            setTimeout(() => { notif.classList.remove('show'); }, notifDuration);
            setTimeout(() => {
                const pt = document.getElementById('player-tutorial');
                document.getElementById('pt-title').innerText = tutorialTitle;
                document.getElementById('pt-desc').innerText = tutorialDesc;
                pt.style.opacity = 1;
                setTimeout(() => { pt.style.opacity = 0; }, 4000);
            }, notifDuration + gap);
        }

        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            if(gameState === "PLAYING") {
                if(e.code === 'KeyE') skillWave(); 
                if(e.code === 'KeyQ') skillUltimate();
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', e => { if(gameState === "PLAYING") { if(e.button === 0) skillSlash(); if(e.button === 2) skillBlink(); } });

        function hitEntity(e, dmg, knockback = 0, srcX = player.x, srcY = player.y) {
            e.hp -= dmg;
            damages.push({ x: e.x, y: e.y - 20, val: Math.floor(dmg), life: 1, color: '#fff' });
            
            if(knockback > 0 && e.type !== 'boss') {
                let kbAngle = Math.atan2(e.y - srcY, e.x - srcX);
                e.x += Math.cos(kbAngle) * knockback;
                e.y += Math.sin(kbAngle) * knockback;
            }

            if(e.hp <= 0) {
                combo++; comboTimer = 120; score += e.score + (combo * 2);
                if(Math.random() < 0.2) orbs.push({ x: e.x, y: e.y, type: 'heal', value: 20 });
                else orbs.push({ x: e.x, y: e.y, type: 'xp', value: e.score });
                createParticles(e.x, e.y, e.color, 12);
                if(e === boss) { boss = null; score += 5000; } else enemies.splice(enemies.indexOf(e), 1);
                if(combo % 10 === 0) shake = 15;
            }
        }

        function skillSlash() {
            if(player.isSwinging) return;
            player.isSwinging = true; player.swingTimer = player.maxSwingTime; player.swingDir *= -1;
            [...enemies, boss].forEach(e => {
                if(!e) return;
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                const a = Math.atan2(e.y - player.y, e.x - player.x);
                let diff = a - player.angle; while(diff > Math.PI) diff -= Math.PI*2; while(diff < -Math.PI) diff += Math.PI*2;
                if(d < player.slashRange + e.size && Math.abs(diff) < 1.3) {
                    hitEntity(e, 40 * player.dmgMult, 25, player.x, player.y);
                    shake = 5;
                }
            });
        }

        function skillWave() {
            if(!player.unlockedWave || player.cdE > 0) return;
            player.cdE = player.maxCdE * player.cdMult;
            projectiles.push({ type: 'wave', x: player.x, y: player.y, angle: player.angle, vx: Math.cos(player.angle)*15, vy: Math.sin(player.angle)*15, life: 80, damage: 85*player.dmgMult, size: 65 });
            shake = 5;
        }

        function skillBlink() {
            if(!player.unlockedBlink || player.cdRMB > 0) return;
            player.cdRMB = player.maxCdRMB * player.cdMult;
            const blinkDist = 280;
            const startX = player.x; const startY = player.y;
            player.x += Math.cos(player.angle) * blinkDist; player.y += Math.sin(player.angle) * blinkDist;
            createParticles(player.x, player.y, 'white', 12); shake = 10;
            blinkTrails.push({ x1: startX, y1: startY, x2: player.x, y2: player.y, life: 30, damage: (40 * player.dmgMult) * 1.5 });
        }

        function skillUltimate() {
            if(!player.unlockedUlt || player.cdQ > 0) return;
            player.cdQ = player.maxCdQ * player.cdMult;
            
            const flash = document.createElement('div');
            flash.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;background:white;z-index:999;transition:opacity 0.5s;";
            document.body.appendChild(flash);
            setTimeout(() => flash.style.opacity = 0, 50);
            setTimeout(() => flash.remove(), 550);

            shake = 40;
            
            [...enemies].forEach(e => {
                createParticles(e.x, e.y, e.color, 15);
                hitEntity(e, 99999, 0); 
            });
            if(boss) hitEntity(boss, 500 * player.dmgMult, 0);
        }

        function skillRicochet() {
            let nearest = null; let minD = 700;
            [...enemies, boss].forEach(e => { if(!e) return; const d = Math.hypot(e.x-player.x, e.y-player.y); if(d<minD){minD=d; nearest=e;} });
            
            if(nearest) {
                const a = Math.atan2(nearest.y - player.y, nearest.x - player.x);
                projectiles.push({ type: 'ricochet', x: player.x, y: player.y, vx: Math.cos(a)*12, vy: Math.sin(a)*12, life: 120, damage: 30*player.dmgMult, size: 8, bounces: 4, lastHit: null });
            }
        }

        function spawnEnemy() {
            if(boss || gameState !== "PLAYING") return;
            const angle = Math.random() * Math.PI * 2;
            const dist = (canvas.width/2 + 100);
            const ex = player.x + Math.cos(angle) * dist;
            const ey = player.y + Math.sin(angle) * dist;
            const r = Math.random();
            let type = 'basic'; 
            
            let shooterCount = enemies.filter(e => e.type === 'shooter').length;

            if (player.level >= 10 && r < 0.15) type = 'seeker';
            else if (player.level >= 7 && r < 0.30) type = 'tank';
            else if (player.level >= 7 && r < 0.50 && shooterCount < 5) type = 'shooter'; // Max 5 Shooters
            else if (player.level >= 4 && r < 0.70) type = 'runner';
            
            let e;
            const hpScale = 1 + (player.level * 0.15);
            
            if(type === 'tank') e = { x: ex, y: ey, maxHp: 160*hpScale, hp: 160*hpScale, speed: 1.2 * 0.85, size: 35, color: '#00ff55', score: 50, type: 'tank' };
            else if(type === 'shooter') e = { x: ex, y: ey, maxHp: 30*hpScale, hp: 30*hpScale, speed: 2.0 * 0.85, size: 18, color: '#ff8800', score: 30, type: 'shooter', shootCd: 60 };
            else if(type === 'runner') e = { x: ex, y: ey, maxHp: 15*hpScale, hp: 15*hpScale, speed: 5.5 * 0.85, size: 15, color: '#ffff00', score: 25, type: 'runner' };
            else if(type === 'seeker') e = { x: ex, y: ey, maxHp: 45*hpScale, hp: 45*hpScale, speed: 3.2 * 0.85, size: 22, color: '#aa00ff', score: 35, type: 'seeker' };
            else e = { x: ex, y: ey, maxHp: 35*hpScale, hp: 35*hpScale, speed: 2.2 * 0.85, size: 20, color: '#ff0055', score: 15, type: 'basic' };
            
            enemies.push(e);
        }

        function spawnBoss() {
            document.getElementById('boss-warning').style.display = 'block';
            shake = 20; setTimeout(() => { document.getElementById('boss-warning').style.display = 'none'; }, 3000);
            const hpScale = 1 + (player.level * 0.3);
            const bossHp = 2500 * hpScale; 
            boss = { x: player.x + 500, y: player.y, size: 80, hp: bossHp, maxHp: bossHp, speed: 2.2 * 0.85, color: '#fff', score: 5000, type: 'boss' };
        }

        function update() {
            if(gameState === "FROZEN" || gameState === "PAUSED" || gameState === "WIN" || gameState === "GAMEOVER") return;

            if(gameState === "MENU") {
                const dx = player.menuTargetX - player.x; const dy = player.menuTargetY - player.y;
                if(Math.hypot(dx, dy) < 50) { player.menuTargetX = Math.random() * WORLD_SIZE; player.menuTargetY = Math.random() * WORLD_SIZE; }
                const angle = Math.atan2(dy, dx); player.x += Math.cos(angle) * 3; player.y += Math.sin(angle) * 3;
                player.angle += (Math.sin(frame * 0.05) * 0.05); 
                camera.x = player.x - canvas.width/2; camera.y = player.y - canvas.height/2;
                frame++; return;
            }

            if(shake > 0) shake *= 0.9;
            if(player.cdRMB > 0) player.cdRMB--; if(player.cdE > 0) player.cdE--; if(player.cdQ > 0) player.cdQ--;
            if(comboTimer > 0) comboTimer--; else combo = 0;

            if(player.unlockedRicochet) {
                player.ricochetCd--;
                if(player.ricochetCd <= 0) { skillRicochet(); player.ricochetCd = 100; }
            }

            document.getElementById('combo-value').innerText = combo;
            document.getElementById('combo-container').style.opacity = combo > 0 ? 1 : 0;
            document.getElementById('score-txt').innerText = score;
            document.getElementById('lvl-txt').innerText = player.level;

            const mx = mouse.x + camera.x; const my = mouse.y + camera.y;
            player.angle = Math.atan2(my - player.y, mx - player.x);
            let dx=0, dy=0;
            if(keys['KeyW']) dy=-1; if(keys['KeyS']) dy=1; if(keys['KeyA']) dx=-1; if(keys['KeyD']) dx=1;
            if(dx||dy){ const l = Math.hypot(dx,dy); player.x += (dx/l)*player.speed; player.y += (dy/l)*player.speed; }
            player.x = Math.max(0, Math.min(WORLD_SIZE, player.x)); player.y = Math.max(0, Math.min(WORLD_SIZE, player.y));
            camera.x = player.x - canvas.width/2; camera.y = player.y - canvas.height/2;

            blinkTrails.forEach((t, i) => {
                t.life--;
                if(t.life > 0) {
                    [...enemies, boss].forEach(e => {
                        if(!e) return;
                        const l2 = (t.x1-t.x2)**2 + (t.y1-t.y2)**2; if(l2 == 0) return;
                        let tVal = ((e.x-t.x1)*(t.x2-t.x1) + (e.y-t.y1)*(t.y2-t.y1)) / l2; tVal = Math.max(0, Math.min(1, tVal));
                        const projX = t.x1 + tVal * (t.x2 - t.x1); const projY = t.y1 + tVal * (t.y2 - t.y1);
                        if(Math.hypot(e.x - projX, e.y - projY) < e.size + 5) hitEntity(e, t.damage, 10, projX, projY);
                    });
                } else blinkTrails.splice(i, 1);
            });

            player.orbitals.forEach(orb => {
                orb.angle += orb.speed;
                const ox = player.x + Math.cos(orb.angle) * orb.radius; const oy = player.y + Math.sin(orb.angle) * orb.radius;
                [...enemies, boss].forEach(e => { if(e && Math.hypot(e.x - ox, e.y - oy) < e.size + orb.size) hitEntity(e, 5, 2, ox, oy); });
            });

            if(player.droneLevel > 0) {
                player.droneCd--;
                if(player.droneCd <= 0) {
                    let nearest = null; let minDst = 500;
                    [...enemies, boss].forEach(e => { if(!e) return; const d = Math.hypot(e.x - player.x, e.y - player.y); if(d < minDst) { minDst = d; nearest = e; } });
                    if(nearest) {
                        const a = Math.atan2(nearest.y - player.y, nearest.x - player.x);
                        projectiles.push({ type: 'drone', x: player.x, y: player.y, vx: Math.cos(a)*10, vy: Math.sin(a)*10, life: 60, damage: 20 * player.dmgMult, size: 4 });
                        player.droneCd = player.droneMaxCd;
                    }
                }
            }

            if(player.staticFieldLevel > 0 && frame % 60 === 0) {
                 let sfRadius = player.staticFieldLevel === 1 ? 100 : (player.staticFieldLevel === 2 ? 150 : 220);
                 let sfDamage = player.staticFieldLevel === 1 ? 10 : (player.staticFieldLevel === 2 ? 18 : 30);
                 [...enemies, boss].forEach(e => { if(!e) return; if(Math.hypot(e.x-player.x, e.y-player.y) < sfRadius) { hitEntity(e, sfDamage, 5, player.x, player.y); createParticles(e.x, e.y, '#00ffff', 5); } });
            }

            frame++; 
            let spawnInterval = Math.max(8, Math.floor(45 / Math.pow(1.20, player.level - 1)));
            if(frame % spawnInterval === 0) spawnEnemy();

            // AI Logika Musuh
            [...enemies, boss].forEach(e => {
                if(!e) return;
                let dist = Math.hypot(player.x - e.x, player.y - e.y);
                let ang = Math.atan2(player.y - e.y, player.x - e.x); 
                
                if(e.type === 'shooter') {
                    if(dist > 350) { e.x += Math.cos(ang)*e.speed; e.y += Math.sin(ang)*e.speed; }
                    else if(dist < 250) { e.x -= Math.cos(ang)*e.speed; e.y -= Math.sin(ang)*e.speed; }
                    
                    if(e.shootCd > 0) e.shootCd--;
                    else {
                        e.shootCd = 100 + Math.random()*50;
                        // Tembakan lurus (tidak homing), kecepatan agak sedikit dipercepat agar menantang
                        enemyProjectiles.push({ 
                            x: e.x, y: e.y, 
                            vx: Math.cos(ang) * 4.5, vy: Math.sin(ang) * 4.5, 
                            life: 250, size: 8, color: 'red', damage: 15 
                        });
                    }
                } else {
                    e.x += Math.cos(ang)*e.speed; e.y += Math.sin(ang)*e.speed;
                }
                
                if(Math.hypot(player.x-e.x, player.y-e.y) < player.size+e.size) player.hp -= (e.type === 'boss' ? 1.5 : 0.4);
            });

            // Logika Proyektil Player
            projectiles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life--;
                
                if(p.type === 'ricochet') {
                    [...enemies, boss].forEach(e => {
                        if(e && e !== p.lastHit && Math.hypot(p.x-e.x, p.y-e.y) < e.size + p.size) {
                            hitEntity(e, p.damage, 10, p.x, p.y);
                            p.lastHit = e; p.bounces--;
                            let next = null; let minD = 400;
                            [...enemies, boss].forEach(e2 => { if(e2 && e2 !== e && Math.hypot(e2.x-p.x, e2.y-p.y) < minD) { minD = Math.hypot(e2.x-p.x, e2.y-p.y); next = e2; } });
                            if(next && p.bounces > 0) {
                                const a = Math.atan2(next.y - p.y, next.x - p.x);
                                p.vx = Math.cos(a)*12; p.vy = Math.sin(a)*12;
                            } else p.life = 0;
                        }
                    });
                } else {
                    [...enemies, boss].forEach(e => { if(e && Math.hypot(p.x-e.x, p.y-e.y) < e.size + p.size) { hitEntity(e, p.damage, 15, p.x, p.y); if(p.type !== 'wave') p.life = 0; } });
                }
                
                if(p.life <= 0) projectiles.splice(i, 1);
            });

            // Logika Proyektil Musuh (LURUS BUKAN HOMING)
            enemyProjectiles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if(Math.hypot(player.x - p.x, player.y - p.y) < player.size + p.size) {
                    player.hp -= p.damage;
                    p.life = 0;
                    createParticles(player.x, player.y, 'red', 10);
                    shake = 5;
                }
                if(p.life <= 0) enemyProjectiles.splice(i, 1);
            });

            orbs.forEach((o, i) => {
                const d = Math.hypot(player.x - o.x, player.y - o.y);
                if(d < player.magnetRange) { const a = Math.atan2(player.y - o.y, player.x - o.x); o.x += Math.cos(a)*15; o.y += Math.sin(a)*15; }
                if(d < player.size + 15) { 
                    if(o.type === 'heal') { player.hp = Math.min(player.hp + 20, player.maxHp); damages.push({ x: player.x, y: player.y - 40, val: "+20 HP", life: 1.5, color: '#00ff55' }); }
                    else {
                        player.xp += o.value; 
                        if(player.xp >= player.maxXp) { 
                            player.xp = 0; player.maxXp *= 1.4; 
                            
                            // ALL STATS UP 12%
                            player.maxHp = Math.floor(player.maxHp * 1.12);
                            player.hp = player.maxHp; 
                            player.dmgMult *= 1.12;
                            player.speed = Math.min(12, player.speed * 1.12); // Speed naik tapi dibatasi max 12
                            player.cdMult = Math.max(0.3, player.cdMult * 0.88); // CD makin cepat (12% reduction), dibatasi min 30% dari awal
                            
                            player.level++; 
                            if(player.level % 10 === 0 && player.level < 30) spawnBoss();
                            if(player.level >= player.maxLevel) { gameState = "WIN"; document.getElementById('win-screen').style.display = 'flex'; return; }
                            gameState = "FROZEN"; setTimeout(() => { showLevelUp(); }, 800);
                        }
                    }
                    orbs.splice(i, 1); 
                }
            });

            particles.forEach((p, i) => { p.x+=p.vx; p.y+=p.vy; p.life-=0.02; if(p.life<=0) particles.splice(i,1); });
            damages.forEach((d, i) => { d.y-=1; d.life-=0.02; if(d.life<=0) damages.splice(i,1); });

            if(player.hp <= 0) {
                if(score > hiScore) { hiScore = score; localStorage.setItem("neonHiScore", hiScore); }
                gameState = "GAMEOVER"; document.getElementById('game-over').style.display = 'flex';
            }
            if(player.swingTimer > 0) player.swingTimer--; else player.isSwinging = false;
        }

        function showLevelUp() {
            const modal = document.getElementById('level-up-modal');
            const box = document.getElementById('cards-box');
            box.innerHTML = "";
            modal.classList.remove('slide-in'); modal.style.display = 'flex';
            void modal.offsetWidth; modal.classList.add('slide-in'); 

            const shuffled = [...upgrades].sort(() => 0.5 - Math.random());
            for(let i=0; i<4; i++) {
                const upg = shuffled[i];
                if(!upg) continue;
                const card = document.createElement('div'); card.className = `card ${upg.type}`;
                card.innerHTML = `<h3>${upg.name}</h3><p>${upg.desc}</p>`;
                card.onclick = () => { 
                    setTimeout(() => { 
                        upg.apply(); modal.style.display = 'none'; modal.classList.remove('slide-in'); 
                        gameState = "PLAYING"; checkSkillUnlocks();
                    }, 200); 
                };
                box.appendChild(card);
            }
        }

        function checkSkillUnlocks() {
            if(player.level === 2) {
                player.unlockedBlink = true;
                showUnlockNotification("SKILL UNLOCKED", "Blink Dash (Teleport)", "COBA BLINK!", "Klik Kanan mouse sekarang");
            }
            else if(player.level === 3) {
                player.unlockedWave = true;
                showUnlockNotification("SKILL UNLOCKED", "Energy Wave (Projectile)", "COBA WAVE!", "Tekan tombol E sekarang");
            }
            else if(player.level === 6) {
                player.unlockedRicochet = true;
                showUnlockNotification("SKILL UNLOCKED", "Ricochet Disc (Passive)", "NEW WEAPON!", "Otomatis memantul ke musuh");
            }
            else if(player.level === 10) {
                player.unlockedUlt = true;
                showUnlockNotification("ULTIMATE UNLOCKED", "DOOMSDAY (NUKE)", "TEKAN Q", "Membunuh semua musuh di layar");
            }
        }

        function createParticles(x, y, col, count) {
            for(let i=0; i<count; i++) particles.push({ x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1, color:col });
        }

        function draw() {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-camera.x + (Math.random()-0.5)*shake, -camera.y + (Math.random()-0.5)*shake);

            const pt = document.getElementById('player-tutorial');
            if(pt.style.opacity > 0) {
                const screenX = player.x - camera.x; const screenY = player.y - camera.y + 95;
                pt.style.left = screenX + 'px'; pt.style.top = screenY + 'px';
            }

            // GRID
            ctx.strokeStyle = '#111'; ctx.lineWidth = 2;
            for(let x = Math.floor(camera.x/100)*100; x < camera.x+canvas.width+100; x+=100) { ctx.beginPath(); ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y+canvas.height); ctx.stroke(); }
            for(let y = Math.floor(camera.y/100)*100; y < camera.y+canvas.height+100; y+=100) { ctx.beginPath(); ctx.moveTo(camera.x, y); ctx.lineTo(camera.x+canvas.width, y); ctx.stroke(); }

            blinkTrails.forEach(t => {
                ctx.save(); ctx.strokeStyle = `rgba(255, 255, 255, ${t.life/30})`; ctx.lineWidth = 4;
                ctx.shadowBlur = 10; ctx.shadowColor = 'white'; ctx.beginPath(); ctx.moveTo(t.x1, t.y1); ctx.lineTo(t.x2, t.y2); ctx.stroke(); ctx.restore();
            });

            orbs.forEach(o => { ctx.fillStyle = o.type === 'heal' ? '#00ff55' : '#ffaa00'; ctx.beginPath(); ctx.arc(o.x, o.y, 6, 0, Math.PI*2); ctx.fill(); });
            
            enemies.forEach(e => { 
                ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = e.color; ctx.fillStyle = e.color; 
                ctx.beginPath();
                if(e.type==='tank') { ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); ctx.fillStyle = 'red'; ctx.fillRect(e.x-20, e.y-e.size-15, 40 * (e.hp/e.maxHp), 5); } 
                else if(e.type==='shooter') { ctx.moveTo(e.x, e.y - e.size); ctx.lineTo(e.x + e.size, e.y + e.size); ctx.lineTo(e.x - e.size, e.y + e.size); } // Gambar Segitiga untuk shooter
                else ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
                ctx.fill(); ctx.restore();
            });
            
            if(boss) {
                ctx.save(); ctx.shadowBlur = 30; ctx.shadowColor = 'red'; ctx.strokeStyle = 'red'; ctx.lineWidth = 5; ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();
                ctx.fillStyle = 'red'; ctx.fillRect(boss.x-60, boss.y-boss.size-25, 120*(boss.hp/boss.maxHp), 10); ctx.strokeStyle='white'; ctx.strokeRect(boss.x-60, boss.y-boss.size-25, 120, 10);
            }

            projectiles.forEach(p => {
                ctx.save();
                if(p.type === 'wave') { ctx.shadowBlur = 20; ctx.shadowColor = 'white'; ctx.strokeStyle = 'white'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, p.angle-1, p.angle+1); ctx.stroke(); }
                else if(p.type === 'drone') { ctx.fillStyle = '#ffffff'; ctx.shadowBlur = 10; ctx.shadowColor='white'; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); }
                else if(p.type === 'ricochet') { ctx.fillStyle = '#ff00ff'; ctx.shadowBlur = 10; ctx.shadowColor='#ff00ff'; ctx.beginPath(); ctx.moveTo(p.x, p.y-5); ctx.lineTo(p.x+5, p.y+5); ctx.lineTo(p.x-5, p.y+5); ctx.fill(); }
                ctx.restore();
            });

            enemyProjectiles.forEach(p => {
                ctx.save();
                ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            });

            // PLAYER
            ctx.save(); ctx.translate(player.x, player.y);
            player.orbitals.forEach(orb => { ctx.save(); ctx.rotate(orb.angle); ctx.translate(orb.radius, 0); ctx.fillStyle = '#ff00ff'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff00ff'; ctx.beginPath(); ctx.arc(0, 0, orb.size, 0, Math.PI*2); ctx.fill(); ctx.restore(); });
            
            if(player.staticFieldLevel > 0) { 
                let sfRadius = player.staticFieldLevel === 1 ? 100 : (player.staticFieldLevel === 2 ? 150 : 220);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random() * 0.4})`; 
                ctx.lineWidth = 1 + player.staticFieldLevel; 
                ctx.beginPath(); 
                ctx.arc(0, 0, sfRadius, 0, Math.PI*2); 
                ctx.stroke(); 
            }

            const hpPct = player.hp / player.maxHp;
            let hpColor = hpPct < 0.9 ? '#ff0033' : '#00ff55';
            ctx.fillStyle = '#111'; ctx.fillRect(-30, 40, 60, 6);
            ctx.fillStyle = hpColor; ctx.fillRect(-30, 40, 60 * hpPct, 6);
            
            // Skill Indicators
            if(player.unlockedWave) {
                const eRatio = Math.max(0, 1 - (player.cdE / (player.maxCdE * player.cdMult)));
                ctx.fillStyle = '#111'; ctx.fillRect(-30, 49, 28, 4); 
                ctx.fillStyle = eRatio === 1 ? 'white' : '#555'; ctx.fillRect(-30, 49, 28 * eRatio, 4); 
                ctx.fillStyle = '#fff'; ctx.font = '8px Arial'; ctx.fillText("E", -28, 52); 
            } else { ctx.fillStyle = '#222'; ctx.fillRect(-30, 49, 28, 4); }

            if(player.unlockedBlink) {
                const bRatio = Math.max(0, 1 - (player.cdRMB / (player.maxCdRMB * player.cdMult)));
                ctx.fillStyle = '#111'; ctx.fillRect(2, 49, 28, 4); 
                ctx.fillStyle = bRatio === 1 ? '#00ccff' : '#004455'; ctx.fillRect(2, 49, 28 * bRatio, 4);
                ctx.fillStyle = '#fff'; ctx.font = '8px Arial'; ctx.fillText("R", 4, 52);
            } else { ctx.fillStyle = '#222'; ctx.fillRect(2, 49, 28, 4); }

            // ULTIMATE BAR (Q)
            if(player.unlockedUlt) {
                const qRatio = Math.max(0, 1 - (player.cdQ / (player.maxCdQ * player.cdMult)));
                ctx.fillStyle = '#111'; ctx.fillRect(-30, 56, 60, 4);
                ctx.fillStyle = qRatio === 1 ? '#ff5500' : '#441100'; 
                ctx.fillRect(-30, 56, 60 * qRatio, 4);
                ctx.fillStyle = '#fff'; ctx.font = '8px Arial'; ctx.fillText(qRatio === 1 ? "Q (READY)" : "Q", -28, 59);
            }

            ctx.rotate(player.angle); 
            ctx.shadowBlur = 20; ctx.shadowColor = '#00ccff'; ctx.fillStyle = '#00ccff';
            ctx.beginPath(); ctx.arc(0,0, player.size, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0; ctx.fillStyle = '#222'; ctx.fillRect(10, 15, 25, 8); 
            ctx.fillStyle = '#fff'; ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.fillRect(35, 18, 50, 4); 

            if(player.isSwinging) { 
                const progress = 1 - (player.swingTimer / player.maxSwingTime);
                const maxArc = 2.4; const startAngle = -1.2;
                ctx.strokeStyle = 'white'; ctx.lineWidth = 12; ctx.lineCap = 'round'; ctx.beginPath();
                if(player.swingDir === 1) ctx.arc(0, 0, player.slashRange, startAngle, startAngle + (maxArc * progress));
                else ctx.arc(0, 0, player.slashRange, startAngle + maxArc - (maxArc * progress), startAngle + maxArc);
                ctx.stroke();
            }
            ctx.restore();

            particles.forEach(p => { ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); ctx.restore(); });
            ctx.font = "bold 16px Arial"; damages.forEach(d => { ctx.fillStyle = d.color; ctx.fillText(d.val, d.x, d.y); });

            ctx.restore(); requestAnimationFrame(draw);
        }

        setInterval(update, 1000/60); draw();
    </script>
</body>
</html>
